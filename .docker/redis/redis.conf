***REMOVED*** Redis configuration file example.
***REMOVED***
***REMOVED*** Note that in order to read the configuration file, Redis must be
***REMOVED*** started with the file path as first argument:
***REMOVED***
***REMOVED*** ./redis-server /path/to/redis.conf

***REMOVED*** Note on units: when memory size is needed, it is possible to specify
***REMOVED*** it in the usual form of 1k 5GB 4M and so forth:
***REMOVED***
***REMOVED*** 1k => 1000 bytes
***REMOVED*** 1kb => 1024 bytes
***REMOVED*** 1m => 1000000 bytes
***REMOVED*** 1mb => 1024*1024 bytes
***REMOVED*** 1g => 1000000000 bytes
***REMOVED*** 1gb => 1024*1024*1024 bytes
***REMOVED***
***REMOVED*** units are case insensitive so 1GB 1Gb 1gB are all the same.

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** INCLUDES ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Include one or more other config files here.  This is useful if you
***REMOVED*** have a standard template that goes to all Redis servers but also need
***REMOVED*** to customize a few per-server settings.  Include files can include
***REMOVED*** other files, so use this wisely.
***REMOVED***
***REMOVED*** Notice option "include" won't be rewritten by command "CONFIG REWRITE"
***REMOVED*** from admin or Redis Sentinel. Since Redis always uses the last processed
***REMOVED*** line as value of a configuration directive, you'd better put includes
***REMOVED*** at the beginning of this file to avoid overwriting config change at runtime.
***REMOVED***
***REMOVED*** If instead you are interested in using includes to override configuration
***REMOVED*** options, it is better to use include as the last line.
***REMOVED***
***REMOVED*** include /path/to/local.conf
***REMOVED*** include /path/to/other.conf

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** MODULES ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Load modules at startup. If the server is not able to load modules
***REMOVED*** it will abort. It is possible to use multiple loadmodule directives.
***REMOVED***
***REMOVED*** loadmodule /path/to/my_module.so
***REMOVED*** loadmodule /path/to/other_module.so

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** NETWORK ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** By default, if no "bind" configuration directive is specified, Redis listens
***REMOVED*** for connections from all the network interfaces available on the server.
***REMOVED*** It is possible to listen to just one or multiple selected interfaces using
***REMOVED*** the "bind" configuration directive, followed by one or more IP addresses.
***REMOVED***
***REMOVED*** Examples:
***REMOVED***
***REMOVED*** bind 192.168.1.100 10.0.0.1
***REMOVED*** bind 127.0.0.1 ::1
***REMOVED***
***REMOVED*** ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
***REMOVED*** internet, binding to all the interfaces is dangerous and will expose the
***REMOVED*** instance to everybody on the internet. So by default we uncomment the
***REMOVED*** following bind directive, that will force Redis to listen only into
***REMOVED*** the IPv4 loopback interface address (this means Redis will be able to
***REMOVED*** accept connections only from clients running into the same computer it
***REMOVED*** is running).
***REMOVED***
***REMOVED*** IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
***REMOVED*** JUST COMMENT THE FOLLOWING LINE.
***REMOVED*** ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bind 127.0.0.1

***REMOVED*** Protected mode is a layer of security protection, in order to avoid that
***REMOVED*** Redis instances left open on the internet are accessed and exploited.
***REMOVED***
***REMOVED*** When protected mode is on and if:
***REMOVED***
***REMOVED*** 1) The server is not binding explicitly to a set of addresses using the
***REMOVED***    "bind" directive.
***REMOVED*** 2) No password is configured.
***REMOVED***
***REMOVED*** The server only accepts connections from clients connecting from the
***REMOVED*** IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
***REMOVED*** sockets.
***REMOVED***
***REMOVED*** By default protected mode is enabled. You should disable it only if
***REMOVED*** you are sure you want clients from other hosts to connect to Redis
***REMOVED*** even if no authentication is configured, nor a specific set of interfaces
***REMOVED*** are explicitly listed using the "bind" directive.
protected-mode yes

***REMOVED*** Accept connections on the specified port, default is 6379 (IANA ***REMOVED***815344).
***REMOVED*** If port 0 is specified Redis will not listen on a TCP socket.
port 6379

***REMOVED*** TCP listen() backlog.
***REMOVED***
***REMOVED*** In high requests-per-second environments you need an high backlog in order
***REMOVED*** to avoid slow clients connections issues. Note that the Linux kernel
***REMOVED*** will silently truncate it to the value of /proc/sys/net/core/somaxconn so
***REMOVED*** make sure to raise both the value of somaxconn and tcp_max_syn_backlog
***REMOVED*** in order to get the desired effect.
tcp-backlog 511

***REMOVED*** Unix socket.
***REMOVED***
***REMOVED*** Specify the path for the Unix socket that will be used to listen for
***REMOVED*** incoming connections. There is no default, so Redis will not listen
***REMOVED*** on a unix socket when not specified.
***REMOVED***
***REMOVED*** unixsocket /tmp/redis.sock
***REMOVED*** unixsocketperm 700

***REMOVED*** Close the connection after a client is idle for N seconds (0 to disable)
timeout 0

***REMOVED*** TCP keepalive.
***REMOVED***
***REMOVED*** If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
***REMOVED*** of communication. This is useful for two reasons:
***REMOVED***
***REMOVED*** 1) Detect dead peers.
***REMOVED*** 2) Take the connection alive from the point of view of network
***REMOVED***    equipment in the middle.
***REMOVED***
***REMOVED*** On Linux, the specified value (in seconds) is the period used to send ACKs.
***REMOVED*** Note that to close the connection the double of the time is needed.
***REMOVED*** On other kernels the period depends on the kernel configuration.
***REMOVED***
***REMOVED*** A reasonable value for this option is 300 seconds, which is the new
***REMOVED*** Redis default starting with Redis 3.2.1.
tcp-keepalive 300

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** GENERAL ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** By default Redis does not run as a daemon. Use 'yes' if you need it.
***REMOVED*** Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize no

***REMOVED*** If you run Redis from upstart or systemd, Redis can interact with your
***REMOVED*** supervision tree. Options:
***REMOVED***   supervised no      - no supervision interaction
***REMOVED***   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
***REMOVED***   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
***REMOVED***   supervised auto    - detect upstart or systemd method based on
***REMOVED***                        UPSTART_JOB or NOTIFY_SOCKET environment variables
***REMOVED*** Note: these supervision methods only signal "process is ready."
***REMOVED***       They do not enable continuous liveness pings back to your supervisor.
supervised no

***REMOVED*** If a pid file is specified, Redis writes it where specified at startup
***REMOVED*** and removes it at exit.
***REMOVED***
***REMOVED*** When the server runs non daemonized, no pid file is created if none is
***REMOVED*** specified in the configuration. When the server is daemonized, the pid file
***REMOVED*** is used even if not specified, defaulting to "/var/run/redis.pid".
***REMOVED***
***REMOVED*** Creating a pid file is best effort: if Redis is not able to create it
***REMOVED*** nothing bad happens, the server will start and run normally.
pidfile /var/run/redis_6379.pid

***REMOVED*** Specify the server verbosity level.
***REMOVED*** This can be one of:
***REMOVED*** debug (a lot of information, useful for development/testing)
***REMOVED*** verbose (many rarely useful info, but not a mess like the debug level)
***REMOVED*** notice (moderately verbose, what you want in production probably)
***REMOVED*** warning (only very important / critical messages are logged)
loglevel notice

***REMOVED*** Specify the log file name. Also the empty string can be used to force
***REMOVED*** Redis to log on the standard output. Note that if you use standard
***REMOVED*** output for logging but daemonize, logs will be sent to /dev/null
logfile ""

***REMOVED*** To enable logging to the system logger, just set 'syslog-enabled' to yes,
***REMOVED*** and optionally update the other syslog parameters to suit your needs.
***REMOVED*** syslog-enabled no

***REMOVED*** Specify the syslog identity.
***REMOVED*** syslog-ident redis

***REMOVED*** Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
***REMOVED*** syslog-facility local0

***REMOVED*** Set the number of databases. The default database is DB 0, you can select
***REMOVED*** a different one on a per-connection basis using SELECT <dbid> where
***REMOVED*** dbid is a number between 0 and 'databases'-1
databases 16

***REMOVED*** By default Redis shows an ASCII art logo only when started to log to the
***REMOVED*** standard output and if the standard output is a TTY. Basically this means
***REMOVED*** that normally a logo is displayed only in interactive sessions.
***REMOVED***
***REMOVED*** However it is possible to force the pre-4.0 behavior and always show a
***REMOVED*** ASCII art logo in startup logs by setting the following option to yes.
always-show-logo yes

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** SNAPSHOTTING  ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED***
***REMOVED*** Save the DB on disk:
***REMOVED***
***REMOVED***   save <seconds> <changes>
***REMOVED***
***REMOVED***   Will save the DB if both the given number of seconds and the given
***REMOVED***   number of write operations against the DB occurred.
***REMOVED***
***REMOVED***   In the example below the behaviour will be to save:
***REMOVED***   after 900 sec (15 min) if at least 1 key changed
***REMOVED***   after 300 sec (5 min) if at least 10 keys changed
***REMOVED***   after 60 sec if at least 10000 keys changed
***REMOVED***
***REMOVED***   Note: you can disable saving completely by commenting out all "save" lines.
***REMOVED***
***REMOVED***   It is also possible to remove all the previously configured save
***REMOVED***   points by adding a save directive with a single empty string argument
***REMOVED***   like in the following example:
***REMOVED***
***REMOVED***   save ""

save 900 1
save 300 10
save 60 10000

***REMOVED*** By default Redis will stop accepting writes if RDB snapshots are enabled
***REMOVED*** (at least one save point) and the latest background save failed.
***REMOVED*** This will make the user aware (in a hard way) that data is not persisting
***REMOVED*** on disk properly, otherwise chances are that no one will notice and some
***REMOVED*** disaster will happen.
***REMOVED***
***REMOVED*** If the background saving process will start working again Redis will
***REMOVED*** automatically allow writes again.
***REMOVED***
***REMOVED*** However if you have setup your proper monitoring of the Redis server
***REMOVED*** and persistence, you may want to disable this feature so that Redis will
***REMOVED*** continue to work as usual even if there are problems with disk,
***REMOVED*** permissions, and so forth.
stop-writes-on-bgsave-error yes

***REMOVED*** Compress string objects using LZF when dump .rdb databases?
***REMOVED*** For default that's set to 'yes' as it's almost always a win.
***REMOVED*** If you want to save some CPU in the saving child set it to 'no' but
***REMOVED*** the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes

***REMOVED*** Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
***REMOVED*** This makes the format more resistant to corruption but there is a performance
***REMOVED*** hit to pay (around 10%) when saving and loading RDB files, so you can disable it
***REMOVED*** for maximum performances.
***REMOVED***
***REMOVED*** RDB files created with checksum disabled have a checksum of zero that will
***REMOVED*** tell the loading code to skip the check.
rdbchecksum yes

***REMOVED*** The filename where to dump the DB
dbfilename dump.rdb

***REMOVED*** The working directory.
***REMOVED***
***REMOVED*** The DB will be written inside this directory, with the filename specified
***REMOVED*** above using the 'dbfilename' configuration directive.
***REMOVED***
***REMOVED*** The Append Only File will also be created inside this directory.
***REMOVED***
***REMOVED*** Note that you must specify a directory here, not a file name.
dir ./

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** REPLICATION ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Master-Replica replication. Use replicaof to make a Redis instance a copy of
***REMOVED*** another Redis server. A few things to understand ASAP about Redis replication.
***REMOVED***
***REMOVED***   +------------------+      +---------------+
***REMOVED***   |      Master      | ---> |    Replica    |
***REMOVED***   | (receive writes) |      |  (exact copy) |
***REMOVED***   +------------------+      +---------------+
***REMOVED***
***REMOVED*** 1) Redis replication is asynchronous, but you can configure a master to
***REMOVED***    stop accepting writes if it appears to be not connected with at least
***REMOVED***    a given number of replicas.
***REMOVED*** 2) Redis replicas are able to perform a partial resynchronization with the
***REMOVED***    master if the replication link is lost for a relatively small amount of
***REMOVED***    time. You may want to configure the replication backlog size (see the next
***REMOVED***    sections of this file) with a sensible value depending on your needs.
***REMOVED*** 3) Replication is automatic and does not need user intervention. After a
***REMOVED***    network partition replicas automatically try to reconnect to masters
***REMOVED***    and resynchronize with them.
***REMOVED***
***REMOVED*** replicaof <masterip> <masterport>

***REMOVED*** If the master is password protected (using the "requirepass" configuration
***REMOVED*** directive below) it is possible to tell the replica to authenticate before
***REMOVED*** starting the replication synchronization process, otherwise the master will
***REMOVED*** refuse the replica request.
***REMOVED***
***REMOVED*** masterauth <master-password>

***REMOVED*** When a replica loses its connection with the master, or when the replication
***REMOVED*** is still in progress, the replica can act in two different ways:
***REMOVED***
***REMOVED*** 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
***REMOVED***    still reply to client requests, possibly with out of date data, or the
***REMOVED***    data set may just be empty if this is the first synchronization.
***REMOVED***
***REMOVED*** 2) if replica-serve-stale-data is set to 'no' the replica will reply with
***REMOVED***    an error "SYNC with master in progress" to all the kind of commands
***REMOVED***    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
***REMOVED***    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
***REMOVED***    COMMAND, POST, HOST: and LATENCY.
***REMOVED***
replica-serve-stale-data yes

***REMOVED*** You can configure a replica instance to accept writes or not. Writing against
***REMOVED*** a replica instance may be useful to store some ephemeral data (because data
***REMOVED*** written on a replica will be easily deleted after resync with the master) but
***REMOVED*** may also cause problems if clients are writing to it because of a
***REMOVED*** misconfiguration.
***REMOVED***
***REMOVED*** Since Redis 2.6 by default replicas are read-only.
***REMOVED***
***REMOVED*** Note: read only replicas are not designed to be exposed to untrusted clients
***REMOVED*** on the internet. It's just a protection layer against misuse of the instance.
***REMOVED*** Still a read only replica exports by default all the administrative commands
***REMOVED*** such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
***REMOVED*** security of read only replicas using 'rename-command' to shadow all the
***REMOVED*** administrative / dangerous commands.
replica-read-only yes

***REMOVED*** Replication SYNC strategy: disk or socket.
***REMOVED***
***REMOVED*** -------------------------------------------------------
***REMOVED*** WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY
***REMOVED*** -------------------------------------------------------
***REMOVED***
***REMOVED*** New replicas and reconnecting replicas that are not able to continue the replication
***REMOVED*** process just receiving differences, need to do what is called a "full
***REMOVED*** synchronization". An RDB file is transmitted from the master to the replicas.
***REMOVED*** The transmission can happen in two different ways:
***REMOVED***
***REMOVED*** 1) Disk-backed: The Redis master creates a new process that writes the RDB
***REMOVED***                 file on disk. Later the file is transferred by the parent
***REMOVED***                 process to the replicas incrementally.
***REMOVED*** 2) Diskless: The Redis master creates a new process that directly writes the
***REMOVED***              RDB file to replica sockets, without touching the disk at all.
***REMOVED***
***REMOVED*** With disk-backed replication, while the RDB file is generated, more replicas
***REMOVED*** can be queued and served with the RDB file as soon as the current child producing
***REMOVED*** the RDB file finishes its work. With diskless replication instead once
***REMOVED*** the transfer starts, new replicas arriving will be queued and a new transfer
***REMOVED*** will start when the current one terminates.
***REMOVED***
***REMOVED*** When diskless replication is used, the master waits a configurable amount of
***REMOVED*** time (in seconds) before starting the transfer in the hope that multiple replicas
***REMOVED*** will arrive and the transfer can be parallelized.
***REMOVED***
***REMOVED*** With slow disks and fast (large bandwidth) networks, diskless replication
***REMOVED*** works better.
repl-diskless-sync no

***REMOVED*** When diskless replication is enabled, it is possible to configure the delay
***REMOVED*** the server waits in order to spawn the child that transfers the RDB via socket
***REMOVED*** to the replicas.
***REMOVED***
***REMOVED*** This is important since once the transfer starts, it is not possible to serve
***REMOVED*** new replicas arriving, that will be queued for the next RDB transfer, so the server
***REMOVED*** waits a delay in order to let more replicas arrive.
***REMOVED***
***REMOVED*** The delay is specified in seconds, and by default is 5 seconds. To disable
***REMOVED*** it entirely just set it to 0 seconds and the transfer will start ASAP.
repl-diskless-sync-delay 5

***REMOVED*** Replicas send PINGs to server in a predefined interval. It's possible to change
***REMOVED*** this interval with the repl_ping_replica_period option. The default value is 10
***REMOVED*** seconds.
***REMOVED***
***REMOVED*** repl-ping-replica-period 10

***REMOVED*** The following option sets the replication timeout for:
***REMOVED***
***REMOVED*** 1) Bulk transfer I/O during SYNC, from the point of view of replica.
***REMOVED*** 2) Master timeout from the point of view of replicas (data, pings).
***REMOVED*** 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
***REMOVED***
***REMOVED*** It is important to make sure that this value is greater than the value
***REMOVED*** specified for repl-ping-replica-period otherwise a timeout will be detected
***REMOVED*** every time there is low traffic between the master and the replica.
***REMOVED***
***REMOVED*** repl-timeout 60

***REMOVED*** Disable TCP_NODELAY on the replica socket after SYNC?
***REMOVED***
***REMOVED*** If you select "yes" Redis will use a smaller number of TCP packets and
***REMOVED*** less bandwidth to send data to replicas. But this can add a delay for
***REMOVED*** the data to appear on the replica side, up to 40 milliseconds with
***REMOVED*** Linux kernels using a default configuration.
***REMOVED***
***REMOVED*** If you select "no" the delay for data to appear on the replica side will
***REMOVED*** be reduced but more bandwidth will be used for replication.
***REMOVED***
***REMOVED*** By default we optimize for low latency, but in very high traffic conditions
***REMOVED*** or when the master and replicas are many hops away, turning this to "yes" may
***REMOVED*** be a good idea.
repl-disable-tcp-nodelay no

***REMOVED*** Set the replication backlog size. The backlog is a buffer that accumulates
***REMOVED*** replica data when replicas are disconnected for some time, so that when a replica
***REMOVED*** wants to reconnect again, often a full resync is not needed, but a partial
***REMOVED*** resync is enough, just passing the portion of data the replica missed while
***REMOVED*** disconnected.
***REMOVED***
***REMOVED*** The bigger the replication backlog, the longer the time the replica can be
***REMOVED*** disconnected and later be able to perform a partial resynchronization.
***REMOVED***
***REMOVED*** The backlog is only allocated once there is at least a replica connected.
***REMOVED***
***REMOVED*** repl-backlog-size 1mb

***REMOVED*** After a master has no longer connected replicas for some time, the backlog
***REMOVED*** will be freed. The following option configures the amount of seconds that
***REMOVED*** need to elapse, starting from the time the last replica disconnected, for
***REMOVED*** the backlog buffer to be freed.
***REMOVED***
***REMOVED*** Note that replicas never free the backlog for timeout, since they may be
***REMOVED*** promoted to masters later, and should be able to correctly "partially
***REMOVED*** resynchronize" with the replicas: hence they should always accumulate backlog.
***REMOVED***
***REMOVED*** A value of 0 means to never release the backlog.
***REMOVED***
***REMOVED*** repl-backlog-ttl 3600

***REMOVED*** The replica priority is an integer number published by Redis in the INFO output.
***REMOVED*** It is used by Redis Sentinel in order to select a replica to promote into a
***REMOVED*** master if the master is no longer working correctly.
***REMOVED***
***REMOVED*** A replica with a low priority number is considered better for promotion, so
***REMOVED*** for instance if there are three replicas with priority 10, 100, 25 Sentinel will
***REMOVED*** pick the one with priority 10, that is the lowest.
***REMOVED***
***REMOVED*** However a special priority of 0 marks the replica as not able to perform the
***REMOVED*** role of master, so a replica with priority of 0 will never be selected by
***REMOVED*** Redis Sentinel for promotion.
***REMOVED***
***REMOVED*** By default the priority is 100.
replica-priority 100

***REMOVED*** It is possible for a master to stop accepting writes if there are less than
***REMOVED*** N replicas connected, having a lag less or equal than M seconds.
***REMOVED***
***REMOVED*** The N replicas need to be in "online" state.
***REMOVED***
***REMOVED*** The lag in seconds, that must be <= the specified value, is calculated from
***REMOVED*** the last ping received from the replica, that is usually sent every second.
***REMOVED***
***REMOVED*** This option does not GUARANTEE that N replicas will accept the write, but
***REMOVED*** will limit the window of exposure for lost writes in case not enough replicas
***REMOVED*** are available, to the specified number of seconds.
***REMOVED***
***REMOVED*** For example to require at least 3 replicas with a lag <= 10 seconds use:
***REMOVED***
***REMOVED*** min-replicas-to-write 3
***REMOVED*** min-replicas-max-lag 10
***REMOVED***
***REMOVED*** Setting one or the other to 0 disables the feature.
***REMOVED***
***REMOVED*** By default min-replicas-to-write is set to 0 (feature disabled) and
***REMOVED*** min-replicas-max-lag is set to 10.

***REMOVED*** A Redis master is able to list the address and port of the attached
***REMOVED*** replicas in different ways. For example the "INFO replication" section
***REMOVED*** offers this information, which is used, among other tools, by
***REMOVED*** Redis Sentinel in order to discover replica instances.
***REMOVED*** Another place where this info is available is in the output of the
***REMOVED*** "ROLE" command of a master.
***REMOVED***
***REMOVED*** The listed IP and address normally reported by a replica is obtained
***REMOVED*** in the following way:
***REMOVED***
***REMOVED***   IP: The address is auto detected by checking the peer address
***REMOVED***   of the socket used by the replica to connect with the master.
***REMOVED***
***REMOVED***   Port: The port is communicated by the replica during the replication
***REMOVED***   handshake, and is normally the port that the replica is using to
***REMOVED***   listen for connections.
***REMOVED***
***REMOVED*** However when port forwarding or Network Address Translation (NAT) is
***REMOVED*** used, the replica may be actually reachable via different IP and port
***REMOVED*** pairs. The following two options can be used by a replica in order to
***REMOVED*** report to its master a specific set of IP and port, so that both INFO
***REMOVED*** and ROLE will report those values.
***REMOVED***
***REMOVED*** There is no need to use both the options if you need to override just
***REMOVED*** the port or the IP address.
***REMOVED***
***REMOVED*** replica-announce-ip 5.5.5.5
***REMOVED*** replica-announce-port 1234

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** SECURITY ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Require clients to issue AUTH <PASSWORD> before processing any other
***REMOVED*** commands.  This might be useful in environments in which you do not trust
***REMOVED*** others with access to the host running redis-server.
***REMOVED***
***REMOVED*** This should stay commented out for backward compatibility and because most
***REMOVED*** people do not need auth (e.g. they run their own servers).
***REMOVED***
***REMOVED*** Warning: since Redis is pretty fast an outside user can try up to
***REMOVED*** 150k passwords per second against a good box. This means that you should
***REMOVED*** use a very strong password otherwise it will be very easy to break.
***REMOVED***
***REMOVED*** requirepass foobared

***REMOVED*** Command renaming.
***REMOVED***
***REMOVED*** It is possible to change the name of dangerous commands in a shared
***REMOVED*** environment. For instance the CONFIG command may be renamed into something
***REMOVED*** hard to guess so that it will still be available for internal-use tools
***REMOVED*** but not available for general clients.
***REMOVED***
***REMOVED*** Example:
***REMOVED***
***REMOVED*** rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
***REMOVED***
***REMOVED*** It is also possible to completely kill a command by renaming it into
***REMOVED*** an empty string:
***REMOVED***
***REMOVED*** rename-command CONFIG ""
***REMOVED***
***REMOVED*** Please note that changing the name of commands that are logged into the
***REMOVED*** AOF file or transmitted to replicas may cause problems.

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** CLIENTS ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Set the max number of connected clients at the same time. By default
***REMOVED*** this limit is set to 10000 clients, however if the Redis server is not
***REMOVED*** able to configure the process file limit to allow for the specified limit
***REMOVED*** the max number of allowed clients is set to the current file limit
***REMOVED*** minus 32 (as Redis reserves a few file descriptors for internal uses).
***REMOVED***
***REMOVED*** Once the limit is reached Redis will close all the new connections sending
***REMOVED*** an error 'max number of clients reached'.
***REMOVED***
***REMOVED*** maxclients 10000

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** MEMORY MANAGEMENT ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Set a memory usage limit to the specified amount of bytes.
***REMOVED*** When the memory limit is reached Redis will try to remove keys
***REMOVED*** according to the eviction policy selected (see maxmemory-policy).
***REMOVED***
***REMOVED*** If Redis can't remove keys according to the policy, or if the policy is
***REMOVED*** set to 'noeviction', Redis will start to reply with errors to commands
***REMOVED*** that would use more memory, like SET, LPUSH, and so on, and will continue
***REMOVED*** to reply to read-only commands like GET.
***REMOVED***
***REMOVED*** This option is usually useful when using Redis as an LRU or LFU cache, or to
***REMOVED*** set a hard memory limit for an instance (using the 'noeviction' policy).
***REMOVED***
***REMOVED*** WARNING: If you have replicas attached to an instance with maxmemory on,
***REMOVED*** the size of the output buffers needed to feed the replicas are subtracted
***REMOVED*** from the used memory count, so that network problems / resyncs will
***REMOVED*** not trigger a loop where keys are evicted, and in turn the output
***REMOVED*** buffer of replicas is full with DELs of keys evicted triggering the deletion
***REMOVED*** of more keys, and so forth until the database is completely emptied.
***REMOVED***
***REMOVED*** In short... if you have replicas attached it is suggested that you set a lower
***REMOVED*** limit for maxmemory so that there is some free RAM on the system for replica
***REMOVED*** output buffers (but this is not needed if the policy is 'noeviction').
***REMOVED***
***REMOVED*** maxmemory <bytes>
memory 268435456

***REMOVED*** MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
***REMOVED*** is reached. You can select among five behaviors:
***REMOVED***
***REMOVED*** volatile-lru -> Evict using approximated LRU among the keys with an expire set.
***REMOVED*** allkeys-lru -> Evict any key using approximated LRU.
***REMOVED*** volatile-lfu -> Evict using approximated LFU among the keys with an expire set.
***REMOVED*** allkeys-lfu -> Evict any key using approximated LFU.
***REMOVED*** volatile-random -> Remove a random key among the ones with an expire set.
***REMOVED*** allkeys-random -> Remove a random key, any key.
***REMOVED*** volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
***REMOVED*** noeviction -> Don't evict anything, just return an error on write operations.
***REMOVED***
***REMOVED*** LRU means Least Recently Used
***REMOVED*** LFU means Least Frequently Used
***REMOVED***
***REMOVED*** Both LRU, LFU and volatile-ttl are implemented using approximated
***REMOVED*** randomized algorithms.
***REMOVED***
***REMOVED*** Note: with any of the above policies, Redis will return an error on write
***REMOVED***       operations, when there are no suitable keys for eviction.
***REMOVED***
***REMOVED***       At the date of writing these commands are: set setnx setex append
***REMOVED***       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
***REMOVED***       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
***REMOVED***       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
***REMOVED***       getset mset msetnx exec sort
***REMOVED***
***REMOVED*** The default is:
***REMOVED***
***REMOVED*** maxmemory-policy noeviction
maxmemory-policy volatile-lru

***REMOVED*** LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
***REMOVED*** algorithms (in order to save memory), so you can tune it for speed or
***REMOVED*** accuracy. For default Redis will check five keys and pick the one that was
***REMOVED*** used less recently, you can change the sample size using the following
***REMOVED*** configuration directive.
***REMOVED***
***REMOVED*** The default of 5 produces good enough results. 10 Approximates very closely
***REMOVED*** true LRU but costs more CPU. 3 is faster but not very accurate.
***REMOVED***
***REMOVED*** maxmemory-samples 5

***REMOVED*** Starting from Redis 5, by default a replica will ignore its maxmemory setting
***REMOVED*** (unless it is promoted to master after a failover or manually). It means
***REMOVED*** that the eviction of keys will be just handled by the master, sending the
***REMOVED*** DEL commands to the replica as keys evict in the master side.
***REMOVED***
***REMOVED*** This behavior ensures that masters and replicas stay consistent, and is usually
***REMOVED*** what you want, however if your replica is writable, or you want the replica to have
***REMOVED*** a different memory setting, and you are sure all the writes performed to the
***REMOVED*** replica are idempotent, then you may change this default (but be sure to understand
***REMOVED*** what you are doing).
***REMOVED***
***REMOVED*** Note that since the replica by default does not evict, it may end using more
***REMOVED*** memory than the one set via maxmemory (there are certain buffers that may
***REMOVED*** be larger on the replica, or data structures may sometimes take more memory and so
***REMOVED*** forth). So make sure you monitor your replicas and make sure they have enough
***REMOVED*** memory to never hit a real out-of-memory condition before the master hits
***REMOVED*** the configured maxmemory setting.
***REMOVED***
***REMOVED*** replica-ignore-maxmemory yes

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** LAZY FREEING ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Redis has two primitives to delete keys. One is called DEL and is a blocking
***REMOVED*** deletion of the object. It means that the server stops processing new commands
***REMOVED*** in order to reclaim all the memory associated with an object in a synchronous
***REMOVED*** way. If the key deleted is associated with a small object, the time needed
***REMOVED*** in order to execute the DEL command is very small and comparable to most other
***REMOVED*** O(1) or O(log_N) commands in Redis. However if the key is associated with an
***REMOVED*** aggregated value containing millions of elements, the server can block for
***REMOVED*** a long time (even seconds) in order to complete the operation.
***REMOVED***
***REMOVED*** For the above reasons Redis also offers non blocking deletion primitives
***REMOVED*** such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
***REMOVED*** FLUSHDB commands, in order to reclaim memory in background. Those commands
***REMOVED*** are executed in constant time. Another thread will incrementally free the
***REMOVED*** object in the background as fast as possible.
***REMOVED***
***REMOVED*** DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.
***REMOVED*** It's up to the design of the application to understand when it is a good
***REMOVED*** idea to use one or the other. However the Redis server sometimes has to
***REMOVED*** delete keys or flush the whole database as a side effect of other operations.
***REMOVED*** Specifically Redis deletes objects independently of a user call in the
***REMOVED*** following scenarios:
***REMOVED***
***REMOVED*** 1) On eviction, because of the maxmemory and maxmemory policy configurations,
***REMOVED***    in order to make room for new data, without going over the specified
***REMOVED***    memory limit.
***REMOVED*** 2) Because of expire: when a key with an associated time to live (see the
***REMOVED***    EXPIRE command) must be deleted from memory.
***REMOVED*** 3) Because of a side effect of a command that stores data on a key that may
***REMOVED***    already exist. For example the RENAME command may delete the old key
***REMOVED***    content when it is replaced with another one. Similarly SUNIONSTORE
***REMOVED***    or SORT with STORE option may delete existing keys. The SET command
***REMOVED***    itself removes any old content of the specified key in order to replace
***REMOVED***    it with the specified string.
***REMOVED*** 4) During replication, when a replica performs a full resynchronization with
***REMOVED***    its master, the content of the whole database is removed in order to
***REMOVED***    load the RDB file just transferred.
***REMOVED***
***REMOVED*** In all the above cases the default is to delete objects in a blocking way,
***REMOVED*** like if DEL was called. However you can configure each case specifically
***REMOVED*** in order to instead release memory in a non-blocking way like if UNLINK
***REMOVED*** was called, using the following configuration directives:

lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** APPEND ONLY MODE ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** By default Redis asynchronously dumps the dataset on disk. This mode is
***REMOVED*** good enough in many applications, but an issue with the Redis process or
***REMOVED*** a power outage may result into a few minutes of writes lost (depending on
***REMOVED*** the configured save points).
***REMOVED***
***REMOVED*** The Append Only File is an alternative persistence mode that provides
***REMOVED*** much better durability. For instance using the default data fsync policy
***REMOVED*** (see later in the config file) Redis can lose just one second of writes in a
***REMOVED*** dramatic event like a server power outage, or a single write if something
***REMOVED*** wrong with the Redis process itself happens, but the operating system is
***REMOVED*** still running correctly.
***REMOVED***
***REMOVED*** AOF and RDB persistence can be enabled at the same time without problems.
***REMOVED*** If the AOF is enabled on startup Redis will load the AOF, that is the file
***REMOVED*** with the better durability guarantees.
***REMOVED***
***REMOVED*** Please check http://redis.io/topics/persistence for more information.

appendonly no

***REMOVED*** The name of the append only file (default: "appendonly.aof")

appendfilename "appendonly.aof"

***REMOVED*** The fsync() call tells the Operating System to actually write data on disk
***REMOVED*** instead of waiting for more data in the output buffer. Some OS will really flush
***REMOVED*** data on disk, some other OS will just try to do it ASAP.
***REMOVED***
***REMOVED*** Redis supports three different modes:
***REMOVED***
***REMOVED*** no: don't fsync, just let the OS flush the data when it wants. Faster.
***REMOVED*** always: fsync after every write to the append only log. Slow, Safest.
***REMOVED*** everysec: fsync only one time every second. Compromise.
***REMOVED***
***REMOVED*** The default is "everysec", as that's usually the right compromise between
***REMOVED*** speed and data safety. It's up to you to understand if you can relax this to
***REMOVED*** "no" that will let the operating system flush the output buffer when
***REMOVED*** it wants, for better performances (but if you can live with the idea of
***REMOVED*** some data loss consider the default persistence mode that's snapshotting),
***REMOVED*** or on the contrary, use "always" that's very slow but a bit safer than
***REMOVED*** everysec.
***REMOVED***
***REMOVED*** More details please check the following article:
***REMOVED*** http://antirez.com/post/redis-persistence-demystified.html
***REMOVED***
***REMOVED*** If unsure, use "everysec".

***REMOVED*** appendfsync always
appendfsync everysec
***REMOVED*** appendfsync no

***REMOVED*** When the AOF fsync policy is set to always or everysec, and a background
***REMOVED*** saving process (a background save or AOF log background rewriting) is
***REMOVED*** performing a lot of I/O against the disk, in some Linux configurations
***REMOVED*** Redis may block too long on the fsync() call. Note that there is no fix for
***REMOVED*** this currently, as even performing fsync in a different thread will block
***REMOVED*** our synchronous write(2) call.
***REMOVED***
***REMOVED*** In order to mitigate this problem it's possible to use the following option
***REMOVED*** that will prevent fsync() from being called in the main process while a
***REMOVED*** BGSAVE or BGREWRITEAOF is in progress.
***REMOVED***
***REMOVED*** This means that while another child is saving, the durability of Redis is
***REMOVED*** the same as "appendfsync none". In practical terms, this means that it is
***REMOVED*** possible to lose up to 30 seconds of log in the worst scenario (with the
***REMOVED*** default Linux settings).
***REMOVED***
***REMOVED*** If you have latency problems turn this to "yes". Otherwise leave it as
***REMOVED*** "no" that is the safest pick from the point of view of durability.

no-appendfsync-on-rewrite no

***REMOVED*** Automatic rewrite of the append only file.
***REMOVED*** Redis is able to automatically rewrite the log file implicitly calling
***REMOVED*** BGREWRITEAOF when the AOF log size grows by the specified percentage.
***REMOVED***
***REMOVED*** This is how it works: Redis remembers the size of the AOF file after the
***REMOVED*** latest rewrite (if no rewrite has happened since the restart, the size of
***REMOVED*** the AOF at startup is used).
***REMOVED***
***REMOVED*** This base size is compared to the current size. If the current size is
***REMOVED*** bigger than the specified percentage, the rewrite is triggered. Also
***REMOVED*** you need to specify a minimal size for the AOF file to be rewritten, this
***REMOVED*** is useful to avoid rewriting the AOF file even if the percentage increase
***REMOVED*** is reached but it is still pretty small.
***REMOVED***
***REMOVED*** Specify a percentage of zero in order to disable the automatic AOF
***REMOVED*** rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

***REMOVED*** An AOF file may be found to be truncated at the end during the Redis
***REMOVED*** startup process, when the AOF data gets loaded back into memory.
***REMOVED*** This may happen when the system where Redis is running
***REMOVED*** crashes, especially when an ext4 filesystem is mounted without the
***REMOVED*** data=ordered option (however this can't happen when Redis itself
***REMOVED*** crashes or aborts but the operating system still works correctly).
***REMOVED***
***REMOVED*** Redis can either exit with an error when this happens, or load as much
***REMOVED*** data as possible (the default now) and start if the AOF file is found
***REMOVED*** to be truncated at the end. The following option controls this behavior.
***REMOVED***
***REMOVED*** If aof-load-truncated is set to yes, a truncated AOF file is loaded and
***REMOVED*** the Redis server starts emitting a log to inform the user of the event.
***REMOVED*** Otherwise if the option is set to no, the server aborts with an error
***REMOVED*** and refuses to start. When the option is set to no, the user requires
***REMOVED*** to fix the AOF file using the "redis-check-aof" utility before to restart
***REMOVED*** the server.
***REMOVED***
***REMOVED*** Note that if the AOF file will be found to be corrupted in the middle
***REMOVED*** the server will still exit with an error. This option only applies when
***REMOVED*** Redis will try to read more data from the AOF file but not enough bytes
***REMOVED*** will be found.
aof-load-truncated yes

***REMOVED*** When rewriting the AOF file, Redis is able to use an RDB preamble in the
***REMOVED*** AOF file for faster rewrites and recoveries. When this option is turned
***REMOVED*** on the rewritten AOF file is composed of two different stanzas:
***REMOVED***
***REMOVED***   [RDB file][AOF tail]
***REMOVED***
***REMOVED*** When loading Redis recognizes that the AOF file starts with the "REDIS"
***REMOVED*** string and loads the prefixed RDB file, and continues loading the AOF
***REMOVED*** tail.
aof-use-rdb-preamble yes

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** LUA SCRIPTING  ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Max execution time of a Lua script in milliseconds.
***REMOVED***
***REMOVED*** If the maximum execution time is reached Redis will log that a script is
***REMOVED*** still in execution after the maximum allowed time and will start to
***REMOVED*** reply to queries with an error.
***REMOVED***
***REMOVED*** When a long running script exceeds the maximum execution time only the
***REMOVED*** SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
***REMOVED*** used to stop a script that did not yet called write commands. The second
***REMOVED*** is the only way to shut down the server in the case a write command was
***REMOVED*** already issued by the script but the user doesn't want to wait for the natural
***REMOVED*** termination of the script.
***REMOVED***
***REMOVED*** Set it to 0 or a negative value for unlimited execution without warnings.
lua-time-limit 5000

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** REDIS CLUSTER  ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED***
***REMOVED*** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
***REMOVED*** WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however
***REMOVED*** in order to mark it as "mature" we need to wait for a non trivial percentage
***REMOVED*** of users to deploy it in production.
***REMOVED*** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
***REMOVED***
***REMOVED*** Normal Redis instances can't be part of a Redis Cluster; only nodes that are
***REMOVED*** started as cluster nodes can. In order to start a Redis instance as a
***REMOVED*** cluster node enable the cluster support uncommenting the following:
***REMOVED***
***REMOVED*** cluster-enabled yes

***REMOVED*** Every cluster node has a cluster configuration file. This file is not
***REMOVED*** intended to be edited by hand. It is created and updated by Redis nodes.
***REMOVED*** Every Redis Cluster node requires a different cluster configuration file.
***REMOVED*** Make sure that instances running in the same system do not have
***REMOVED*** overlapping cluster configuration file names.
***REMOVED***
***REMOVED*** cluster-config-file nodes-6379.conf

***REMOVED*** Cluster node timeout is the amount of milliseconds a node must be unreachable
***REMOVED*** for it to be considered in failure state.
***REMOVED*** Most other internal time limits are multiple of the node timeout.
***REMOVED***
***REMOVED*** cluster-node-timeout 15000

***REMOVED*** A replica of a failing master will avoid to start a failover if its data
***REMOVED*** looks too old.
***REMOVED***
***REMOVED*** There is no simple way for a replica to actually have an exact measure of
***REMOVED*** its "data age", so the following two checks are performed:
***REMOVED***
***REMOVED*** 1) If there are multiple replicas able to failover, they exchange messages
***REMOVED***    in order to try to give an advantage to the replica with the best
***REMOVED***    replication offset (more data from the master processed).
***REMOVED***    Replicas will try to get their rank by offset, and apply to the start
***REMOVED***    of the failover a delay proportional to their rank.
***REMOVED***
***REMOVED*** 2) Every single replica computes the time of the last interaction with
***REMOVED***    its master. This can be the last ping or command received (if the master
***REMOVED***    is still in the "connected" state), or the time that elapsed since the
***REMOVED***    disconnection with the master (if the replication link is currently down).
***REMOVED***    If the last interaction is too old, the replica will not try to failover
***REMOVED***    at all.
***REMOVED***
***REMOVED*** The point "2" can be tuned by user. Specifically a replica will not perform
***REMOVED*** the failover if, since the last interaction with the master, the time
***REMOVED*** elapsed is greater than:
***REMOVED***
***REMOVED***   (node-timeout * replica-validity-factor) + repl-ping-replica-period
***REMOVED***
***REMOVED*** So for example if node-timeout is 30 seconds, and the replica-validity-factor
***REMOVED*** is 10, and assuming a default repl-ping-replica-period of 10 seconds, the
***REMOVED*** replica will not try to failover if it was not able to talk with the master
***REMOVED*** for longer than 310 seconds.
***REMOVED***
***REMOVED*** A large replica-validity-factor may allow replicas with too old data to failover
***REMOVED*** a master, while a too small value may prevent the cluster from being able to
***REMOVED*** elect a replica at all.
***REMOVED***
***REMOVED*** For maximum availability, it is possible to set the replica-validity-factor
***REMOVED*** to a value of 0, which means, that replicas will always try to failover the
***REMOVED*** master regardless of the last time they interacted with the master.
***REMOVED*** (However they'll always try to apply a delay proportional to their
***REMOVED*** offset rank).
***REMOVED***
***REMOVED*** Zero is the only value able to guarantee that when all the partitions heal
***REMOVED*** the cluster will always be able to continue.
***REMOVED***
***REMOVED*** cluster-replica-validity-factor 10

***REMOVED*** Cluster replicas are able to migrate to orphaned masters, that are masters
***REMOVED*** that are left without working replicas. This improves the cluster ability
***REMOVED*** to resist to failures as otherwise an orphaned master can't be failed over
***REMOVED*** in case of failure if it has no working replicas.
***REMOVED***
***REMOVED*** Replicas migrate to orphaned masters only if there are still at least a
***REMOVED*** given number of other working replicas for their old master. This number
***REMOVED*** is the "migration barrier". A migration barrier of 1 means that a replica
***REMOVED*** will migrate only if there is at least 1 other working replica for its master
***REMOVED*** and so forth. It usually reflects the number of replicas you want for every
***REMOVED*** master in your cluster.
***REMOVED***
***REMOVED*** Default is 1 (replicas migrate only if their masters remain with at least
***REMOVED*** one replica). To disable migration just set it to a very large value.
***REMOVED*** A value of 0 can be set but is useful only for debugging and dangerous
***REMOVED*** in production.
***REMOVED***
***REMOVED*** cluster-migration-barrier 1

***REMOVED*** By default Redis Cluster nodes stop accepting queries if they detect there
***REMOVED*** is at least an hash slot uncovered (no available node is serving it).
***REMOVED*** This way if the cluster is partially down (for example a range of hash slots
***REMOVED*** are no longer covered) all the cluster becomes, eventually, unavailable.
***REMOVED*** It automatically returns available as soon as all the slots are covered again.
***REMOVED***
***REMOVED*** However sometimes you want the subset of the cluster which is working,
***REMOVED*** to continue to accept queries for the part of the key space that is still
***REMOVED*** covered. In order to do so, just set the cluster-require-full-coverage
***REMOVED*** option to no.
***REMOVED***
***REMOVED*** cluster-require-full-coverage yes

***REMOVED*** This option, when set to yes, prevents replicas from trying to failover its
***REMOVED*** master during master failures. However the master can still perform a
***REMOVED*** manual failover, if forced to do so.
***REMOVED***
***REMOVED*** This is useful in different scenarios, especially in the case of multiple
***REMOVED*** data center operations, where we want one side to never be promoted if not
***REMOVED*** in the case of a total DC failure.
***REMOVED***
***REMOVED*** cluster-replica-no-failover no

***REMOVED*** In order to setup your cluster make sure to read the documentation
***REMOVED*** available at http://redis.io web site.

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** CLUSTER DOCKER/NAT support  ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** In certain deployments, Redis Cluster nodes address discovery fails, because
***REMOVED*** addresses are NAT-ted or because ports are forwarded (the typical case is
***REMOVED*** Docker and other containers).
***REMOVED***
***REMOVED*** In order to make Redis Cluster working in such environments, a static
***REMOVED*** configuration where each node knows its public address is needed. The
***REMOVED*** following two options are used for this scope, and are:
***REMOVED***
***REMOVED*** * cluster-announce-ip
***REMOVED*** * cluster-announce-port
***REMOVED*** * cluster-announce-bus-port
***REMOVED***
***REMOVED*** Each instruct the node about its address, client port, and cluster message
***REMOVED*** bus port. The information is then published in the header of the bus packets
***REMOVED*** so that other nodes will be able to correctly map the address of the node
***REMOVED*** publishing the information.
***REMOVED***
***REMOVED*** If the above options are not used, the normal Redis Cluster auto-detection
***REMOVED*** will be used instead.
***REMOVED***
***REMOVED*** Note that when remapped, the bus port may not be at the fixed offset of
***REMOVED*** clients port + 10000, so you can specify any port and bus-port depending
***REMOVED*** on how they get remapped. If the bus-port is not set, a fixed offset of
***REMOVED*** 10000 will be used as usually.
***REMOVED***
***REMOVED*** Example:
***REMOVED***
***REMOVED*** cluster-announce-ip 10.1.1.5
***REMOVED*** cluster-announce-port 6379
***REMOVED*** cluster-announce-bus-port 6380

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** SLOW LOG ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** The Redis Slow Log is a system to log queries that exceeded a specified
***REMOVED*** execution time. The execution time does not include the I/O operations
***REMOVED*** like talking with the client, sending the reply and so forth,
***REMOVED*** but just the time needed to actually execute the command (this is the only
***REMOVED*** stage of command execution where the thread is blocked and can not serve
***REMOVED*** other requests in the meantime).
***REMOVED***
***REMOVED*** You can configure the slow log with two parameters: one tells Redis
***REMOVED*** what is the execution time, in microseconds, to exceed in order for the
***REMOVED*** command to get logged, and the other parameter is the length of the
***REMOVED*** slow log. When a new command is logged the oldest one is removed from the
***REMOVED*** queue of logged commands.

***REMOVED*** The following time is expressed in microseconds, so 1000000 is equivalent
***REMOVED*** to one second. Note that a negative number disables the slow log, while
***REMOVED*** a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

***REMOVED*** There is no limit to this length. Just be aware that it will consume memory.
***REMOVED*** You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** LATENCY MONITOR ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** The Redis latency monitoring subsystem samples different operations
***REMOVED*** at runtime in order to collect data related to possible sources of
***REMOVED*** latency of a Redis instance.
***REMOVED***
***REMOVED*** Via the LATENCY command this information is available to the user that can
***REMOVED*** print graphs and obtain reports.
***REMOVED***
***REMOVED*** The system only logs operations that were performed in a time equal or
***REMOVED*** greater than the amount of milliseconds specified via the
***REMOVED*** latency-monitor-threshold configuration directive. When its value is set
***REMOVED*** to zero, the latency monitor is turned off.
***REMOVED***
***REMOVED*** By default latency monitoring is disabled since it is mostly not needed
***REMOVED*** if you don't have latency issues, and collecting data has a performance
***REMOVED*** impact, that while very small, can be measured under big load. Latency
***REMOVED*** monitoring can easily be enabled at runtime using the command
***REMOVED*** "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
latency-monitor-threshold 0

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** EVENT NOTIFICATION ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Redis can notify Pub/Sub clients about events happening in the key space.
***REMOVED*** This feature is documented at http://redis.io/topics/notifications
***REMOVED***
***REMOVED*** For instance if keyspace events notification is enabled, and a client
***REMOVED*** performs a DEL operation on key "foo" stored in the Database 0, two
***REMOVED*** messages will be published via Pub/Sub:
***REMOVED***
***REMOVED*** PUBLISH __keyspace@0__:foo del
***REMOVED*** PUBLISH __keyevent@0__:del foo
***REMOVED***
***REMOVED*** It is possible to select the events that Redis will notify among a set
***REMOVED*** of classes. Every class is identified by a single character:
***REMOVED***
***REMOVED***  K     Keyspace events, published with __keyspace@<db>__ prefix.
***REMOVED***  E     Keyevent events, published with __keyevent@<db>__ prefix.
***REMOVED***  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
***REMOVED***  $     String commands
***REMOVED***  l     List commands
***REMOVED***  s     Set commands
***REMOVED***  h     Hash commands
***REMOVED***  z     Sorted set commands
***REMOVED***  x     Expired events (events generated every time a key expires)
***REMOVED***  e     Evicted events (events generated when a key is evicted for maxmemory)
***REMOVED***  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
***REMOVED***
***REMOVED***  The "notify-keyspace-events" takes as argument a string that is composed
***REMOVED***  of zero or multiple characters. The empty string means that notifications
***REMOVED***  are disabled.
***REMOVED***
***REMOVED***  Example: to enable list and generic events, from the point of view of the
***REMOVED***           event name, use:
***REMOVED***
***REMOVED***  notify-keyspace-events Elg
***REMOVED***
***REMOVED***  Example 2: to get the stream of the expired keys subscribing to channel
***REMOVED***             name __keyevent@0__:expired use:
***REMOVED***
***REMOVED***  notify-keyspace-events Ex
***REMOVED***
***REMOVED***  By default all notifications are disabled because most users don't need
***REMOVED***  this feature and the feature has some overhead. Note that if you don't
***REMOVED***  specify at least one of K or E, no events will be delivered.
notify-keyspace-events ""

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** ADVANCED CONFIG ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***

***REMOVED*** Hashes are encoded using a memory efficient data structure when they have a
***REMOVED*** small number of entries, and the biggest entry does not exceed a given
***REMOVED*** threshold. These thresholds can be configured using the following directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

***REMOVED*** Lists are also encoded in a special way to save a lot of space.
***REMOVED*** The number of entries allowed per internal list node can be specified
***REMOVED*** as a fixed maximum size or a maximum number of elements.
***REMOVED*** For a fixed maximum size, use -5 through -1, meaning:
***REMOVED*** -5: max size: 64 Kb  <-- not recommended for normal workloads
***REMOVED*** -4: max size: 32 Kb  <-- not recommended
***REMOVED*** -3: max size: 16 Kb  <-- probably not recommended
***REMOVED*** -2: max size: 8 Kb   <-- good
***REMOVED*** -1: max size: 4 Kb   <-- good
***REMOVED*** Positive numbers mean store up to _exactly_ that number of elements
***REMOVED*** per list node.
***REMOVED*** The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
***REMOVED*** but if your use case is unique, adjust the settings as necessary.
list-max-ziplist-size -2

***REMOVED*** Lists may also be compressed.
***REMOVED*** Compress depth is the number of quicklist ziplist nodes from *each* side of
***REMOVED*** the list to *exclude* from compression.  The head and tail of the list
***REMOVED*** are always uncompressed for fast push/pop operations.  Settings are:
***REMOVED*** 0: disable all list compression
***REMOVED*** 1: depth 1 means "don't start compressing until after 1 node into the list,
***REMOVED***    going from either the head or tail"
***REMOVED***    So: [head]->node->node->...->node->[tail]
***REMOVED***    [head], [tail] will always be uncompressed; inner nodes will compress.
***REMOVED*** 2: [head]->[next]->node->node->...->node->[prev]->[tail]
***REMOVED***    2 here means: don't compress head or head->next or tail->prev or tail,
***REMOVED***    but compress all nodes between them.
***REMOVED*** 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
***REMOVED*** etc.
list-compress-depth 0

***REMOVED*** Sets have a special encoding in just one case: when a set is composed
***REMOVED*** of just strings that happen to be integers in radix 10 in the range
***REMOVED*** of 64 bit signed integers.
***REMOVED*** The following configuration setting sets the limit in the size of the
***REMOVED*** set in order to use this special memory saving encoding.
set-max-intset-entries 512

***REMOVED*** Similarly to hashes and lists, sorted sets are also specially encoded in
***REMOVED*** order to save a lot of space. This encoding is only used when the length and
***REMOVED*** elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

***REMOVED*** HyperLogLog sparse representation bytes limit. The limit includes the
***REMOVED*** 16 bytes header. When an HyperLogLog using the sparse representation crosses
***REMOVED*** this limit, it is converted into the dense representation.
***REMOVED***
***REMOVED*** A value greater than 16000 is totally useless, since at that point the
***REMOVED*** dense representation is more memory efficient.
***REMOVED***
***REMOVED*** The suggested value is ~ 3000 in order to have the benefits of
***REMOVED*** the space efficient encoding without slowing down too much PFADD,
***REMOVED*** which is O(N) with the sparse encoding. The value can be raised to
***REMOVED*** ~ 10000 when CPU is not a concern, but space is, and the data set is
***REMOVED*** composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000

***REMOVED*** Streams macro node max size / items. The stream data structure is a radix
***REMOVED*** tree of big nodes that encode multiple items inside. Using this configuration
***REMOVED*** it is possible to configure how big a single node can be in bytes, and the
***REMOVED*** maximum number of items it may contain before switching to a new node when
***REMOVED*** appending new stream entries. If any of the following settings are set to
***REMOVED*** zero, the limit is ignored, so for instance it is possible to set just a
***REMOVED*** max entires limit by setting max-bytes to 0 and max-entries to the desired
***REMOVED*** value.
stream-node-max-bytes 4096
stream-node-max-entries 100

***REMOVED*** Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
***REMOVED*** order to help rehashing the main Redis hash table (the one mapping top-level
***REMOVED*** keys to values). The hash table implementation Redis uses (see dict.c)
***REMOVED*** performs a lazy rehashing: the more operation you run into a hash table
***REMOVED*** that is rehashing, the more rehashing "steps" are performed, so if the
***REMOVED*** server is idle the rehashing is never complete and some more memory is used
***REMOVED*** by the hash table.
***REMOVED***
***REMOVED*** The default is to use this millisecond 10 times every second in order to
***REMOVED*** actively rehash the main dictionaries, freeing memory when possible.
***REMOVED***
***REMOVED*** If unsure:
***REMOVED*** use "activerehashing no" if you have hard latency requirements and it is
***REMOVED*** not a good thing in your environment that Redis can reply from time to time
***REMOVED*** to queries with 2 milliseconds delay.
***REMOVED***
***REMOVED*** use "activerehashing yes" if you don't have such hard requirements but
***REMOVED*** want to free memory asap when possible.
activerehashing yes

***REMOVED*** The client output buffer limits can be used to force disconnection of clients
***REMOVED*** that are not reading data from the server fast enough for some reason (a
***REMOVED*** common reason is that a Pub/Sub client can't consume messages as fast as the
***REMOVED*** publisher can produce them).
***REMOVED***
***REMOVED*** The limit can be set differently for the three different classes of clients:
***REMOVED***
***REMOVED*** normal -> normal clients including MONITOR clients
***REMOVED*** replica  -> replica clients
***REMOVED*** pubsub -> clients subscribed to at least one pubsub channel or pattern
***REMOVED***
***REMOVED*** The syntax of every client-output-buffer-limit directive is the following:
***REMOVED***
***REMOVED*** client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
***REMOVED***
***REMOVED*** A client is immediately disconnected once the hard limit is reached, or if
***REMOVED*** the soft limit is reached and remains reached for the specified number of
***REMOVED*** seconds (continuously).
***REMOVED*** So for instance if the hard limit is 32 megabytes and the soft limit is
***REMOVED*** 16 megabytes / 10 seconds, the client will get disconnected immediately
***REMOVED*** if the size of the output buffers reach 32 megabytes, but will also get
***REMOVED*** disconnected if the client reaches 16 megabytes and continuously overcomes
***REMOVED*** the limit for 10 seconds.
***REMOVED***
***REMOVED*** By default normal clients are not limited because they don't receive data
***REMOVED*** without asking (in a push way), but just after a request, so only
***REMOVED*** asynchronous clients may create a scenario where data is requested faster
***REMOVED*** than it can read.
***REMOVED***
***REMOVED*** Instead there is a default limit for pubsub and replica clients, since
***REMOVED*** subscribers and replicas receive data in a push fashion.
***REMOVED***
***REMOVED*** Both the hard or the soft limit can be disabled by setting them to zero.
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

***REMOVED*** Client query buffers accumulate new commands. They are limited to a fixed
***REMOVED*** amount by default in order to avoid that a protocol desynchronization (for
***REMOVED*** instance due to a bug in the client) will lead to unbound memory usage in
***REMOVED*** the query buffer. However you can configure it here if you have very special
***REMOVED*** needs, such us huge multi/exec requests or alike.
***REMOVED***
***REMOVED*** client-query-buffer-limit 1gb

***REMOVED*** In the Redis protocol, bulk requests, that are, elements representing single
***REMOVED*** strings, are normally limited ot 512 mb. However you can change this limit
***REMOVED*** here.
***REMOVED***
***REMOVED*** proto-max-bulk-len 512mb

***REMOVED*** Redis calls an internal function to perform many background tasks, like
***REMOVED*** closing connections of clients in timeout, purging expired keys that are
***REMOVED*** never requested, and so forth.
***REMOVED***
***REMOVED*** Not all tasks are performed with the same frequency, but Redis checks for
***REMOVED*** tasks to perform according to the specified "hz" value.
***REMOVED***
***REMOVED*** By default "hz" is set to 10. Raising the value will use more CPU when
***REMOVED*** Redis is idle, but at the same time will make Redis more responsive when
***REMOVED*** there are many keys expiring at the same time, and timeouts may be
***REMOVED*** handled with more precision.
***REMOVED***
***REMOVED*** The range is between 1 and 500, however a value over 100 is usually not
***REMOVED*** a good idea. Most users should use the default of 10 and raise this up to
***REMOVED*** 100 only in environments where very low latency is required.
hz 10

***REMOVED*** Normally it is useful to have an HZ value which is proportional to the
***REMOVED*** number of clients connected. This is useful in order, for instance, to
***REMOVED*** avoid too many clients are processed for each background task invocation
***REMOVED*** in order to avoid latency spikes.
***REMOVED***
***REMOVED*** Since the default HZ value by default is conservatively set to 10, Redis
***REMOVED*** offers, and enables by default, the ability to use an adaptive HZ value
***REMOVED*** which will temporary raise when there are many connected clients.
***REMOVED***
***REMOVED*** When dynamic HZ is enabled, the actual configured HZ will be used as
***REMOVED*** as a baseline, but multiples of the configured HZ value will be actually
***REMOVED*** used as needed once more clients are connected. In this way an idle
***REMOVED*** instance will use very little CPU time while a busy instance will be
***REMOVED*** more responsive.
dynamic-hz yes

***REMOVED*** When a child rewrites the AOF file, if the following option is enabled
***REMOVED*** the file will be fsync-ed every 32 MB of data generated. This is useful
***REMOVED*** in order to commit the file to the disk more incrementally and avoid
***REMOVED*** big latency spikes.
aof-rewrite-incremental-fsync yes

***REMOVED*** When redis saves RDB file, if the following option is enabled
***REMOVED*** the file will be fsync-ed every 32 MB of data generated. This is useful
***REMOVED*** in order to commit the file to the disk more incrementally and avoid
***REMOVED*** big latency spikes.
rdb-save-incremental-fsync yes

***REMOVED*** Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
***REMOVED*** idea to start with the default settings and only change them after investigating
***REMOVED*** how to improve the performances and how the keys LFU change over time, which
***REMOVED*** is possible to inspect via the OBJECT FREQ command.
***REMOVED***
***REMOVED*** There are two tunable parameters in the Redis LFU implementation: the
***REMOVED*** counter logarithm factor and the counter decay time. It is important to
***REMOVED*** understand what the two parameters mean before changing them.
***REMOVED***
***REMOVED*** The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
***REMOVED*** uses a probabilistic increment with logarithmic behavior. Given the value
***REMOVED*** of the old counter, when a key is accessed, the counter is incremented in
***REMOVED*** this way:
***REMOVED***
***REMOVED*** 1. A random number R between 0 and 1 is extracted.
***REMOVED*** 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
***REMOVED*** 3. The counter is incremented only if R < P.
***REMOVED***
***REMOVED*** The default lfu-log-factor is 10. This is a table of how the frequency
***REMOVED*** counter changes with a different number of accesses with different
***REMOVED*** logarithmic factors:
***REMOVED***
***REMOVED*** +--------+------------+------------+------------+------------+------------+
***REMOVED*** | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
***REMOVED*** +--------+------------+------------+------------+------------+------------+
***REMOVED*** | 0      | 104        | 255        | 255        | 255        | 255        |
***REMOVED*** +--------+------------+------------+------------+------------+------------+
***REMOVED*** | 1      | 18         | 49         | 255        | 255        | 255        |
***REMOVED*** +--------+------------+------------+------------+------------+------------+
***REMOVED*** | 10     | 10         | 18         | 142        | 255        | 255        |
***REMOVED*** +--------+------------+------------+------------+------------+------------+
***REMOVED*** | 100    | 8          | 11         | 49         | 143        | 255        |
***REMOVED*** +--------+------------+------------+------------+------------+------------+
***REMOVED***
***REMOVED*** NOTE: The above table was obtained by running the following commands:
***REMOVED***
***REMOVED***   redis-benchmark -n 1000000 incr foo
***REMOVED***   redis-cli object freq foo
***REMOVED***
***REMOVED*** NOTE 2: The counter initial value is 5 in order to give new objects a chance
***REMOVED*** to accumulate hits.
***REMOVED***
***REMOVED*** The counter decay time is the time, in minutes, that must elapse in order
***REMOVED*** for the key counter to be divided by two (or decremented if it has a value
***REMOVED*** less <= 10).
***REMOVED***
***REMOVED*** The default value for the lfu-decay-time is 1. A Special value of 0 means to
***REMOVED*** decay the counter every time it happens to be scanned.
***REMOVED***
***REMOVED*** lfu-log-factor 10
***REMOVED*** lfu-decay-time 1

***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** ACTIVE DEFRAGMENTATION ***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED******REMOVED***
***REMOVED***
***REMOVED*** WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested
***REMOVED*** even in production and manually tested by multiple engineers for some
***REMOVED*** time.
***REMOVED***
***REMOVED*** What is active defragmentation?
***REMOVED*** -------------------------------
***REMOVED***
***REMOVED*** Active (online) defragmentation allows a Redis server to compact the
***REMOVED*** spaces left between small allocations and deallocations of data in memory,
***REMOVED*** thus allowing to reclaim back memory.
***REMOVED***
***REMOVED*** Fragmentation is a natural process that happens with every allocator (but
***REMOVED*** less so with Jemalloc, fortunately) and certain workloads. Normally a server
***REMOVED*** restart is needed in order to lower the fragmentation, or at least to flush
***REMOVED*** away all the data and create it again. However thanks to this feature
***REMOVED*** implemented by Oran Agra for Redis 4.0 this process can happen at runtime
***REMOVED*** in an "hot" way, while the server is running.
***REMOVED***
***REMOVED*** Basically when the fragmentation is over a certain level (see the
***REMOVED*** configuration options below) Redis will start to create new copies of the
***REMOVED*** values in contiguous memory regions by exploiting certain specific Jemalloc
***REMOVED*** features (in order to understand if an allocation is causing fragmentation
***REMOVED*** and to allocate it in a better place), and at the same time, will release the
***REMOVED*** old copies of the data. This process, repeated incrementally for all the keys
***REMOVED*** will cause the fragmentation to drop back to normal values.
***REMOVED***
***REMOVED*** Important things to understand:
***REMOVED***
***REMOVED*** 1. This feature is disabled by default, and only works if you compiled Redis
***REMOVED***    to use the copy of Jemalloc we ship with the source code of Redis.
***REMOVED***    This is the default with Linux builds.
***REMOVED***
***REMOVED*** 2. You never need to enable this feature if you don't have fragmentation
***REMOVED***    issues.
***REMOVED***
***REMOVED*** 3. Once you experience fragmentation, you can enable this feature when
***REMOVED***    needed with the command "CONFIG SET activedefrag yes".
***REMOVED***
***REMOVED*** The configuration parameters are able to fine tune the behavior of the
***REMOVED*** defragmentation process. If you are not sure about what they mean it is
***REMOVED*** a good idea to leave the defaults untouched.

***REMOVED*** Enabled active defragmentation
***REMOVED*** activedefrag yes

***REMOVED*** Minimum amount of fragmentation waste to start active defrag
***REMOVED*** active-defrag-ignore-bytes 100mb

***REMOVED*** Minimum percentage of fragmentation to start active defrag
***REMOVED*** active-defrag-threshold-lower 10

***REMOVED*** Maximum percentage of fragmentation at which we use maximum effort
***REMOVED*** active-defrag-threshold-upper 100

***REMOVED*** Minimal effort for defrag in CPU percentage
***REMOVED*** active-defrag-cycle-min 5

***REMOVED*** Maximal effort for defrag in CPU percentage
***REMOVED*** active-defrag-cycle-max 75

***REMOVED*** Maximum number of set/hash/zset/list fields that will be processed from
***REMOVED*** the main dictionary scan
***REMOVED*** active-defrag-max-scan-fields 1000
